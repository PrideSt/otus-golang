package generator

import (
	"fmt"
	"strings"
	"text/template"

	"github.com/PrideSt/otus-golang/hw09_generator_of_validators/go-validate/internal/parser"
)

var (
	fileTemplate = `// Code generated by go-validate. DO NOT EDIT.
package {{ .Package }}
{{ template "importTpl" .Imports }}

{{- range .Structs }}
	{{- template "structTpl" . }}
{{- end }}
`
	importTpl = `
import (
{{- range .}}
	{{ if (ne . "") -}}
	"{{- . }}"
	{{- end}}
{{- end }}
)`
	structTpl = `

func (r {{ .Name }}) Validate() ([]validator.ValidationError, error) {
	errs := []validator.ValidationError{}
	{{- range .Fields }}
		{{- template "validateFieldsTpl" . }}
	{{- end }}

	return errs, nil
}`
	switchValidatorTpl = `
	{{- if (eq .IType "int") }}
		{{- if (eq .Vr.FuncName "min") }}
			{{- template "validateMin" . -}}
		{{- else if (eq .Vr.FuncName "max") }}
			{{- template "validateMax" . -}}
		{{- else if (eq .Vr.FuncName "in") }}
			{{- template "validateInInt" . -}}
		{{- end }}
	{{- else if (eq .IType "string") }}
		{{- if (eq .Vr.FuncName "len") }}
			{{- template "validateLen" . -}}
		{{- else if (eq .Vr.FuncName "regexp") }}
			{{- template "validateRegexp" . -}}
		{{- else if (eq .Vr.FuncName "in") }}
			{{- template "validateInStr" . -}}
		{{- end }}
	{{- end }}`
	validateFieldsTpl = `
{{ $fieldName := .Name }}
{{- $type := .InternalType }}
{{- $dType := .DType }}
{{- if (eq .Kind "array") }}
	{{- if (eq 0 (len .Validators) ) }}
	for k := range r.{{ $fieldName }} {
		{{- template "validateClass" concat $fieldName "[k]" -}}
	}
	{{- else }}
		{{- range .Validators }}
	for k := range r.{{ $fieldName }} {
		{{- template "switchValidatorTpl" makeNameValidatorType (concat $fieldName "[k]") . $type $dType -}}
	}
		{{- end }}
	{{- end }}
{{- else if (eq .Kind "class") }}
	{{- template "validateClass" $fieldName -}}
{{- else }}
	{{- range .Validators }}
		{{- template "switchValidatorTpl" makeNameValidatorType $fieldName . $type $dType }}
	{{- end }}
{{- end }}`
	validateClass = `
	if vObj, ok := interface{}(r.{{ . }}).(validator.Validated); ok {
		objErr, fail := vObj.Validate()
		if fail != nil {
			return nil, fail
		}
		errs = append(errs, objErr...)
	}`
	validateMin = `
	if r.{{ .Name }} < {{ index .Vr.Args 0 }} {
		errs = append(errs, validator.NewError(
			"{{ .Name }}",
			fmt.Errorf("value must be greater or equal then %d, but actual %d", {{ index .Vr.Args 0 }}, r.{{ .Name }}),
		))
	}`
	validateMax = `
	if r.{{ .Name }} > {{ index .Vr.Args 0 }} {
		errs = append(errs, validator.NewError(
			"{{ .Name }}",
			fmt.Errorf("value must be less or equal then %d, but actual %d", {{ index .Vr.Args 0 }}, r.{{ .Name }}),
		))
	}`
	validateInInt = `
	{
		set := []{{ .DType }}{ {{- join .Vr.Args ", " -}} }
		isIn := false
		for _, val := range set {
			if r.{{ .Name }} == val {
				isIn = true
				break
			}
		}
		if !isIn {
			errs = append(errs, validator.NewError(
				"{{ .Name }}",
				fmt.Errorf("value must be equal one of: %v, but actual %d", set, r.{{ .Name }}),
			))
		}
	}`
	validateLen = `
	if len(r.{{ .Name }}) != {{ index .Vr.Args 0 }} {
		errs = append(errs, validator.NewError(
			"{{ .Name }}",
			fmt.Errorf("len must be equal %d, but actual len is %d", {{ index .Vr.Args 0 }}, len(r.{{ .Name }})),
		))
	}`
	validateRegexp = `
	{
		pattern := "{{ index .Vr.Args 0 }}"
		if matched, err := regexp.MatchString(pattern, r.{{ .Name }}); err != nil {
			return nil, err
		} else if !matched {
			errs = append(errs, validator.NewError(
				"{{ .Name }}",
				fmt.Errorf("value must match regexp %q, but actual %q", pattern, r.{{ .Name }}),
			))
		}
	}`
	validateInStr = `
	{
		set := []{{ .DType }}{ {{- join (wrapQuot .Vr.Args) ", " -}} }
		isIn := false
		for _, val := range set {
			if r.{{ .Name }} == val {
				isIn = true
				break
			}
		}
		if !isIn {
			errs = append(errs, validator.NewError(
				"{{ .Name }}",
				fmt.Errorf("value must be equal one of: %v, but actual %q", set, r.{{ .Name }}),
			))
		}
	}`
)

// makeNameValidatorType build special struct to render validate function.
func makeNameValidatorType(n string, vr parser.ValidatorDesc, it string, dt string) nameValidatorType {
	return nameValidatorType{n, vr, it, dt}
}

// wrapQuot surround strings in s with quotes.
func wrapQuot(s []string) []string {
	quotedStr := make([]string, len(s))
	for i, ss := range s {
		quotedStr[i] = fmt.Sprintf("%q", ss)
	}
	return quotedStr
}

type nameValidatorType struct {
	Name  string
	Vr    parser.ValidatorDesc
	IType string
	DType string
}

// concat join some strings without delimiter.
func concat(s ...string) string {
	return strings.Join(s, "")
}

// list of used sub templates.
var templates = map[string]string{
	"importTpl":          importTpl,
	"structTpl":          structTpl,
	"switchValidatorTpl": switchValidatorTpl,
	"validateFieldsTpl":  validateFieldsTpl,
	"validateClass":      validateClass,
	"validateMin":        validateMin,
	"validateMax":        validateMax,
	"validateInInt":      validateInInt,
	"validateLen":        validateLen,
	"validateRegexp":     validateRegexp,
	"validateInStr":      validateInStr,
}

// funcs is a function list used in templates.
var funcs = template.FuncMap{
	"concat":                concat,
	"join":                  strings.Join,
	"makeNameValidatorType": makeNameValidatorType,
	"wrapQuot":              wrapQuot,
}
