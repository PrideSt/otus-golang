// Code generated by go-validate. DO NOT EDIT.
package models

import (
	"fmt"
	"regexp"

	"github.com/PrideSt/otus-golang/hw09_generator_of_validators/validator"
)

func (r App) Validate() ([]validator.ValidationError, error) {
	errs := []validator.ValidationError{}

	if len(r.Version) != 5 {
		errs = append(errs, validator.NewError(
			"Version",
			fmt.Errorf("len must be equal %d, but actual len is %d", 5, len(r.Version)),
		))
	}

	return errs, nil
}

func (r ClassProperty) Validate() ([]validator.ValidationError, error) {
	errs := []validator.ValidationError{}

	if len(r.ID) != 36 {
		errs = append(errs, validator.NewError(
			"ID",
			fmt.Errorf("len must be equal %d, but actual len is %d", 36, len(r.ID)),
		))
	}

	if vObj, ok := interface{}(r.OneResp).(validator.Validated); ok {
		objErr, fail := vObj.Validate()
		if fail != nil {
			return nil, fail
		}
		errs = append(errs, objErr...)
	}

	return errs, nil
}

func (r Response) Validate() ([]validator.ValidationError, error) {
	errs := []validator.ValidationError{}

	{
		set := []int{200, 404, 500}
		isIn := false
		for _, val := range set {
			if r.Code == val {
				isIn = true
				break
			}
		}
		if !isIn {
			errs = append(errs, validator.NewError(
				"Code",
				fmt.Errorf("value must be equal one of: %v, but actual %d", set, r.Code),
			))
		}
	}

	return errs, nil
}

func (r User) Validate() ([]validator.ValidationError, error) {
	errs := []validator.ValidationError{}

	if len(r.ID) != 36 {
		errs = append(errs, validator.NewError(
			"ID",
			fmt.Errorf("len must be equal %d, but actual len is %d", 36, len(r.ID)),
		))
	}

	if r.Age < 18 {
		errs = append(errs, validator.NewError(
			"Age",
			fmt.Errorf("value must be greater or equal then %d, but actual %d", 18, r.Age),
		))
	}
	if r.Age > 50 {
		errs = append(errs, validator.NewError(
			"Age",
			fmt.Errorf("value must be less or equal then %d, but actual %d", 50, r.Age),
		))
	}

	{
		pattern := "^\\w+@\\w+\\.\\w+$"
		if matched, err := regexp.MatchString(pattern, r.Email); err != nil {
			return nil, err
		} else if !matched {
			errs = append(errs, validator.NewError(
				"Email",
				fmt.Errorf("value must match regexp %q, but actual %q", pattern, r.Email),
			))
		}
	}

	{
		set := []UserRole{"admin", "stuff"}
		isIn := false
		for _, val := range set {
			if r.Role == val {
				isIn = true
				break
			}
		}
		if !isIn {
			errs = append(errs, validator.NewError(
				"Role",
				fmt.Errorf("value must be equal one of: %v, but actual %q", set, r.Role),
			))
		}
	}

	for k := range r.Phones {
		if len(r.Phones[k]) != 11 {
			errs = append(errs, validator.NewError(
				"Phones[k]",
				fmt.Errorf("len must be equal %d, but actual len is %d", 11, len(r.Phones[k])),
			))
		}
	}

	return errs, nil
}

func (r WithEmbedded) Validate() ([]validator.ValidationError, error) {
	errs := []validator.ValidationError{}

	if len(r.ID) != 36 {
		errs = append(errs, validator.NewError(
			"ID",
			fmt.Errorf("len must be equal %d, but actual len is %d", 36, len(r.ID)),
		))
	}

	{
		set := []int{200, 404, 500}
		isIn := false
		for _, val := range set {
			if r.Code == val {
				isIn = true
				break
			}
		}
		if !isIn {
			errs = append(errs, validator.NewError(
				"Code",
				fmt.Errorf("value must be equal one of: %v, but actual %d", set, r.Code),
			))
		}
	}

	return errs, nil
}
