// The following directive is necessary to generates benchmark's fixtures:
// It can be invoked by running go generate

// +build ignore

package main

import (
	"flag"
	"fmt"
	"math/rand"
	"os"
	"text/template"
	"time"

	"github.com/PrideSt/otus-golang/hw03_frequency_analysis/internal/txt"
)

var (
	pkgName  string
	outFile  string
	dictSize int
	textSize int
)

const (
	ExitCodeInvalidArgPkgName = 1 << iota
	ExitCodeInvalidArgOutFile
	ExitCodeInvalidArgDictSize
	ExitCodeInvalidArgTextSize
	ExitCodeCreateOutFileFailed
	ExitCodeCloseOutFileFailed
)

func init() {
	flag.StringVar(&pkgName, "pkg-name", "", "specify go package name")
	flag.StringVar(&outFile, "out", "", "path to output file to save generated text")
	flag.IntVar(&dictSize, "dict-size", 0, "specify amount of words in dictionary")
	flag.IntVar(&textSize, "text-size", 0, "specify amount of words in text")
}

func main() {
	flag.Parse()

	errCode := 0
	if pkgName == "" {
		fmt.Println("package name not specified, pass -pkg-name argument's value")
		errCode |= ExitCodeInvalidArgPkgName
	}

	if outFile == "" {
		fmt.Println("output filename not specified, pass -out argument's value")
		errCode |= ExitCodeInvalidArgOutFile
	}

	if dictSize == 0 {
		fmt.Println("invalid dict-size, require > 0")
		errCode |= ExitCodeInvalidArgDictSize
	}

	if textSize == 0 {
		fmt.Println("invalid text-size, require > 0")
		errCode |= ExitCodeInvalidArgTextSize
	}

	if errCode > 0 {
		os.Exit(errCode)
	}

	alplabet := []byte(`abcdefghijklmnopqrstuvwxyz`) // 26
	offset := 17576                                  // aaa
	step := 31
	dict, _ := txt.GenDict(dictSize, alplabet, offset, step)

	randSeed := time.Now().UnixNano()
	text := txt.GenText(dict, textSize, rand.New(rand.NewSource(randSeed)))
	varName := fmt.Sprintf("Txt%dDict%d", textSize, dictSize)

	f, err := os.Create(outFile)
	if err != nil {
		fmt.Println(fmt.Errorf("unable to open file %q for writing: %w", outFile, err))
		os.Exit(ExitCodeCreateOutFileFailed)
	}
	defer func() {
		err := f.Close()
		if err != nil {
			fmt.Println(fmt.Errorf("error when close file %q: %w", outFile, err))
			os.Exit(ExitCodeCloseOutFileFailed)
		}
	}()

	packageTemplate.Execute(f, struct {
		CreatedAt time.Time
		RndSeed   int64
		PkgName   string
		VarName   string
		VarValue  string
	}{
		CreatedAt: time.Now().Round(0).UTC(),
		RndSeed:   randSeed,
		PkgName:   pkgName,
		VarName:   varName,
		VarValue:  text,
	})
}

var packageTemplate = template.Must(template.New("").Parse(`
// Code generated by go generate; DO NOT EDIT.
// generated at {{ .CreatedAt }}
// random seed {{ .RndSeed }}
package {{ .PkgName }}

var {{ .VarName }} string = "{{- .VarValue -}}"
`))
